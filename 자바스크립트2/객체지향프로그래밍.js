/*
특징 4가지
은닉성 - 자동차 => 껍데기가 없으면 오염이 쉽고 고장나기 쉬움.
              그래서 껍데기를 씌워서 보호하자. 클로저 처럼 변수랑 데이터를 보호.
              접근 권한(private, public)을 만든다.
상속성 - 처음부터 새로 안만들고 근접한것들이 있으면 상속받아 만든다.
         코드의 재활용도를 높히고 프레임워크를 만드는데 가장 중요한 성격
다형성 - 다양한 성격을 의미, overloading(오버로딩), overridng(오버라이딩) 두가지 지원
          a= 4+5;    + 연산자는 정수 더하기
          b = "4" + "5"; +연산자는 문자열 합치기.
          이렇게 같은 더하기 여도 다른역할(형상)이 있다 그것을 다형성.
추상성 - 클래스 내부구조의 정확한 내용을 몰라도 사용이 가능한 성격
         추상성이 극대화 될수록 사용자가 편해진다.
         자동차 => 발명(부품 하나하나 깎아 만든다.), 상당히 구체적
                => 핸리포드 컨베이어벨트
          추상화된 자동차가 사용자는 편하다. 그러나 만드는 사람은 더 어렵다.

1 세대 : 기계어, 어셈블리어 - 하드웨어를 속속들이 알아서 프로그램 해야한다. 레지스터 16개
2 세대 : 코볼(데이터처리 전문), 포트란 (과학기술계산용) 두개 기능을 합친 언어를 만들 수준이 안되서
         각각 전문처리언어, 모로가도 서울만 가면된다.
         대충만들어서 결과가 나온다.
3 세대 : 구조적 프로그래밍 언어, 모듈 단위로 프로그램을 작성한다.(함수, 프로시저가 존재)
         함수는 반환값이 있고, 프로시저는 반환을 못함.  = > 둘이 합쳐서 하는게 (c언어)
         하드웨어로부터 개발자를 떼어 놓는다. 개발자가 하드웨어의 구체적 사용법을 몰라도
         프로그램이 가능하다. c언어는 모든 하드웨어를 파일과 동일시함.
         파일 입출력만 하면 모든 장비제어가 가능하다. ==> 자바, 자바스크립트
         구조체 => 데이터만 묶어 놓은 데이터의 추상화
         함수 => 처리과정의 추상화
         알고리즘 중심
4세대 : 구조체를 하나 만들고, 이 구조체의 데이터를 접근하기 위한 함수를 만든다.
        구조체 1000개, 구조체마다 접근함수 최소 5개 이상임.
        1000 개면, 최소 함수개 5000개
        구조체랑 관련있는 함수를 묶지 => 클래스 라고 하자.
        데이터와 절차의 추상화 : 클래스(변수와 함수의 묶음.)

        구조체 => 클래스
        데이터만 있는 클래스도 있고, 데이터와 함수가 같이있는 클래스도 있고, 함수만 있는 클래스도 있다.

        스택이나 큐 링크드리스트 - 부품형 클래스, 자기자체가 완결구조가 아니고
        다른 클래스에서 갖다 쓸 클래스들
*/

 class Person{
  // 생성자는 개체 생성시 호출되는 특별한 유형의 함수다.
  // 호출자가 => 시스템이다./ 우리가 아무거나 만들어 놓고 애가 생성자야라고하면 시스템은 못알아 듣는다.
  // 자바클래스명(), 자바스크립트, constructor()
  // 사용자가 생성자를 안만들면 시스템이 만들어서라도 호출한다. 무조건 호출함
  // 자바스크립트는 오버로딩(overloading)이 지원되지 않는다.
  // 그래서 다양한 생성자를 못만든다.
  // 소멸자 -> 객체가 소멸될때인데, 우리가 그 시점을 지정못하기 때문에 안씀.
  // GC(Gabage Collector)가 있는 언어들은 소멸자를 신경안씀. GC가 알아서 해결하기 때문이다
  // name; //공동의 변수 let 사용불가
  // age; //공동의 변수

  //자바처럼 private이나 protected, public이 없다.
  //다만 언더바(_) 하나를 붙이면 아 저거 보호하려고 하는구나 라고 생각한다.
  // 근데 접근은 되는데 사실상 개발자들끼리 조심하자고 하는거임
  constructor(name="홍길동",age=12){
    //this : 객체자신을 가리키는 자기 참조자라고 한다.
    this._name = name //변수 선언
    this._age = age;
    //공통메모리 공간이 있어야함 => 공동의 변수
    console.log("Person 객체 생성")
  }
  display(){
    console.log(`${this.name} ${this.age}`)
  }
  // 속성 : property - 함수와 변수의 중간쯤 존재
  // 만들때는 get함수명 () {..} 실제 사용시에는 변수처럼 사용할수 있다.
  get Age(){
    return this.age;
  }
  set Age(value){
    this.age = value;
  }
  get Name(){
    return "이름은 : "+this.name;
  }
  set Name(value){  //디폴트값은 못넣음.
    this.name = value;
  }
}

let person = new Person();
let person2 = new Person("홍길동",34);
person.display()
person2.display()
console.log(person2.Age)
person2.Age = 55; // 사용시에 변수처럼 사용한다. 만드는 쪽에선 함수형태이다. 
                  // set이 구현되어야한다. 
console.log(person2.Age) //get이 구현되어야 한다.

console.log(person.Name)
person.Name = "강감찬";
console.log(person.Name)


// 못막음 _ 있는 것을 암묵적으로 private으로 본다.
person._name =" eee"
console.log(person._name)